<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <!-- VR表示に必要なmetaタグを追加 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <!-- WebXRはHTTPS接続が必須 -->
    <title>Three.js Meta Quest VRコントローラー表示 (修正版)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #202020; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            z-index: 1;
            pointer-events: none; /* クリックイベントを透過させる */
        }
        #info p {
            margin: 5px 0;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            display: inline-block; /* 中央寄せのため */
            border-radius: 5px;
        }
        /* VRButtonのスタイルはVRButton.jsが適用するので、ここでは不要 */
        /* 古いボタンのスタイルを削除 */
    </style>
</head>
<body>
    <div id="info">
        <p>Meta Quest VRコントローラー表示</p>
        <p>VRデバイスを接続してVRモードを開始するには下の「ENTER VR」ボタンをクリックしてください</p>
    </div>

    <!-- Import Maps を使用して Three.js とアドオンを読み込む -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        // 必要なモジュールをインポート
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        // GLTFLoaderはXRControllerModelFactory内部で使用されるため、通常は明示的なインポート不要

        let camera, scene, renderer;
        let controllers = []; // コントローラー(入力ソース)の配列
        let controllerGrips = []; // コントローラーグリップ(モデル表示用)の配列
        let controllerModelFactory; // コントローラーモデルをロードするファクトリ
        let infoElement;

        init();
        animate(); // アニメーションループを開始

        function init() {
            infoElement = document.getElementById('info');

            // シーンの作成
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x202020);

            // カメラの作成
            // PerspectiveCamera(視野角, アスペクト比, nearクリップ, farクリップ)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            // 初期カメラ位置を設定 (VRセッション開始時にリセットされることが多い)
            camera.position.set(0, 1.6, 2);

            // ライトの追加
            const ambientLight = new THREE.AmbientLight(0x606060); // 環境光を少し強く
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // 平行光源
            directionalLight.position.set(1, 1.5, 1).normalize();
            scene.add(directionalLight);

            // レンダラーの作成と設定
            renderer = new THREE.WebGLRenderer({ antialias: true }); // アンチエイリアス有効
            renderer.setPixelRatio(window.devicePixelRatio); // デバイスのピクセル比を設定
            renderer.setSize(window.innerWidth, window.innerHeight); // レンダラーのサイズをウィンドウに合わせる
            renderer.outputEncoding = THREE.sRGBEncoding; // 色空間をsRGBに設定 (重要)
            renderer.xr.enabled = true; // WebXRを有効化
            document.body.appendChild(renderer.domElement); // レンダラーのcanvasをDOMに追加

            // VRボタンの作成と追加 (Three.js提供のVRButtonを使用)
            // 引数にレンダラーを渡し、必要な設定 (参照空間タイプなど) を自動で行う
            const vrButton = VRButton.createButton(renderer);
            document.body.appendChild(vrButton);

            // VRButtonのエラーハンドリングを追加
            vrButton.addEventListener('error', (event) => {
                console.error("VR 初期化エラー:", event.detail?.error || event);
                const p = document.createElement('p');
                p.style.color = 'red';
                p.textContent = `VRエラー: ${event.detail?.error?.message || '不明なエラー'}. デバイス接続やブラウザ設定を確認してください。`;
                if (infoElement) infoElement.appendChild(p);
                // ボタンのテキストも更新する (VRButton内部で処理される場合もある)
                if (vrButton.textContent !== 'VRを終了') {
                    vrButton.textContent = 'VR利用不可';
                    vrButton.style.cursor = 'auto';
                    vrButton.style.opacity = '0.5';
                    vrButton.onclick = null; // クリックイベントを無効化
                }
            });
             vrButton.addEventListener('click', () => {
                 // ボタンクリック直後はまだセッション状態が変わらないことがあるため、
                 // sessionstart/sessionend イベントで表示を切り替えるのが確実
                 console.log("VR Button clicked. Session state:", renderer.xr.isPresenting);
            });


            // 床のグリッドヘルパーを作成
            const gridHelper = new THREE.GridHelper(10, 10, 0x888888, 0x444444); // グリッド線と中心線の色を指定
            scene.add(gridHelper);

            // コントローラーモデルファクトリの初期化
            // これが接続されたコントローラーに対応するモデルをロードする
            controllerModelFactory = new XRControllerModelFactory();
            // 必要であればモデルファイルのパスを指定:
            // controllerModelFactory.setPath("path/to/controller/models/");

            // コントローラーの設定
            setupControllers();

            // ウィンドウリサイズイベントリスナー
            window.addEventListener('resize', onWindowResize);

            // XRセッション開始/終了イベントリスナー
            renderer.xr.addEventListener('sessionstart', onSessionStart);
            renderer.xr.addEventListener('sessionend', onSessionEnd);
        }

        function setupControllers() {
            // 既存のコントローラーオブジェクトをシーンから削除（再接続時などに備える）
            controllers.forEach(controller => scene.remove(controller));
            controllerGrips.forEach(grip => scene.remove(grip));
            controllers = [];
            controllerGrips = [];

            // 左右のコントローラー (0: 左手, 1: 右手 のことが多い)
            for (let i = 0; i < 2; i++) {
                // コントローラー入力ソースの取得 (ポインターやイベント処理用)
                const controller = renderer.xr.getController(i);
                controller.userData.controllerIndex = i; // インデックスを保持
                scene.add(controller);
                controllers.push(controller);

                // コントローラーグリップの取得 (モデル表示用)
                // グリップはコントローラーの物理的な位置・向きを表す
                const controllerGrip = renderer.xr.getControllerGrip(i);
                // XRControllerModelFactory を使ってモデルをロードし、グリップに追加
                const model = controllerModelFactory.createControllerModel(controllerGrip);
                controllerGrip.add(model);
                scene.add(controllerGrip);
                controllerGrips.push(controllerGrip);

                // --- コントローラーイベントリスナーの設定 ---

                // 接続時
                controller.addEventListener('connected', (event) => {
                    console.log(`Controller ${i} connected:`, event.data);
                    // 接続情報 (特に入力プロファイル) を確認できる
                    if (event.data.profiles) {
                        console.log(`Profiles: ${event.data.profiles.join(', ')}`);
                    }
                    // ポインター（レイ）を追加
                    addPointer(controller);
                });

                // 切断時
                controller.addEventListener('disconnected', () => {
                    console.log(`Controller ${i} disconnected`);
                    // ポインターを削除
                    const pointer = controller.getObjectByName('pointer');
                    if (pointer) {
                        controller.remove(pointer);
                    }
                    // モデルはグリップに紐づいているので、グリップが削除されれば消える
                    // (sessionendでまとめて削除するなどでも良い)
                });

                // select (トリガー等) イベント
                controller.addEventListener('selectstart', onSelectStart);
                controller.addEventListener('selectend', onSelectEnd);

                // squeeze (グリップボタン等) イベント (必要に応じて追加)
                // controller.addEventListener('squeezestart', onSqueezeStart);
                // controller.addEventListener('squeezeend', onSqueezeEnd);
            }
        }

        // コントローラーにポインター（線）を追加する関数
        function addPointer(controller) {
            // 既存のポインターがあれば削除
             const existingPointer = controller.getObjectByName('pointer');
             if (existingPointer) controller.remove(existingPointer);

            // シンプルな線ジオメトリを作成 (原点からZ軸マイナス方向へ)
            const pointerGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 0, -1) // 長さ1の線分
            ]);
            const pointerMaterial = new THREE.LineBasicMaterial({
                color: 0xffffff, // 白色
                linewidth: 2 // linewidthは環境により効かないことがある
            });
            const pointerLine = new THREE.Line(pointerGeometry, pointerMaterial);
            pointerLine.name = 'pointer';
            pointerLine.scale.z = 5; // ポインターの長さを調整 (ここでは5メートル)
            controller.add(pointerLine); // コントローラーに追加
        }

        // Select (トリガー) 開始イベントハンドラ
        function onSelectStart(event) {
            const controller = event.target;
            const index = controller.userData.controllerIndex;
            console.log(`Controller ${index} select start`);
            // 例: ポインターの色を変える
            const pointer = controller.getObjectByName('pointer');
            if (pointer && pointer.material) {
                pointer.material.color.setHex(0x00ff00); // 緑色に
            }
            // 他のインタラクション処理 (オブジェクト掴むなど)
        }

        // Select (トリガー) 終了イベントハンドラ
        function onSelectEnd(event) {
            const controller = event.target;
            const index = controller.userData.controllerIndex;
            console.log(`Controller ${index} select end`);
            // 例: ポインターの色を戻す
            const pointer = controller.getObjectByName('pointer');
            if (pointer && pointer.material) {
                pointer.material.color.setHex(0xffffff); // 白色に戻す
            }
            // 他のインタラクション処理 (オブジェクト離すなど)
        }

        // XRセッション開始時の処理
        function onSessionStart() {
            console.log("XR Session Started");
            if (infoElement) infoElement.style.display = 'none'; // 情報表示を隠す
             // 必要であればコントローラーを再セットアップ
            // setupControllers();
        }

        // XRセッション終了時の処理
        function onSessionEnd() {
            console.log("XR Session Ended");
            if (infoElement) infoElement.style.display = 'block'; // 情報表示を再表示
            // カメラの位置や向きを初期状態に戻す（任意）
            camera.position.set(0, 1.6, 2);
            camera.rotation.set(0, 0, 0);
            camera.updateMatrixWorld(); // 更新を反映

             // コントローラー関連オブジェクトをクリア（任意、メモリ解放のため）
            // controllers.forEach(controller => {
            //     const pointer = controller.getObjectByName('pointer');
            //     if (pointer) controller.remove(pointer);
            //     scene.remove(controller);
            // });
            // controllerGrips.forEach(grip => {
            //     // モデルの削除 (XRControllerModelFactoryが管理している場合、グリップ削除で十分かも)
            //     while (grip.children.length > 0) {
            //         grip.remove(grip.children[0]);
            //     }
            //     scene.remove(grip);
            // });
            // controllers = [];
            // controllerGrips = [];
            // setupControllers(); // 再度セットアップしておく場合
        }

        // ウィンドウリサイズ時の処理
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight; // カメラのアスペクト比を更新
            camera.updateProjectionMatrix(); // カメラの投影行列を更新
            renderer.setSize(window.innerWidth, window.innerHeight); // レンダラーのサイズを更新
        }

        // アニメーションループの設定
        function animate() {
            // requestAnimationFrame の代わりに setAnimationLoop を使用 (WebXR推奨)
            renderer.setAnimationLoop(render);
        }

        // 毎フレームの描画処理
        function render() {
            // コントローラーの状態に基づく処理 (例: ボタン入力、位置取得など)
            // controllers.forEach((controller, index) => {
            //     if (controller.userData.gamepad) { // ゲームパッドAPI経由での入力取得
            //         console.log(`Controller ${index} Gamepad:`, controller.userData.gamepad);
            //     }
            // });

            // シーンとカメラを描画
            renderer.render(scene, camera);
        }

    </script>
</body>
</html>